\documentclass[12pt, letterpaper, oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage{authoraftertitle}
\usepackage{tabulary}
\usepackage{listings}

% Line-wrapping in lstlisting
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily,
    columns=fullflexible,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

% Document metadata
\title{Interim Report \& Risk Assessment}
\author{Deniz Ozmus}
\date{December 2017}

\def \projecttitle {csar: Query-driven Code Search and Refactoring Framework}
\def \supervisor {Michael Tautschnig}

% We load hyperref here as a hacky fix to the tableofcontents not rendering
\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref}

% Document
\begin{document}

% Title page
\begin{titlepage}
    \centering
    {\Large \MyTitle\par}
    \vspace{0.5cm}
    {\projecttitle\par}
    \vspace{3cm}
    {\MyAuthor\par}
    \vspace{0.5cm}
    {\itshape Supervised by }{ \supervisor\par}
    \vspace{10cm}
    {\today\par}
\end{titlepage}

% Table of contents
\tableofcontents
\newpage

% Introduction
\section{Introduction}
\subsection{What is csar?}

csar aims to be a unified framework for code searching and refactoring. It will take as input descriptions of searches and corresponding refactors in a newly devised query language called the csar query language. This results in a versatile and descriptive framework, which can target any programming language without the developer needing to know the specifics.

Furthermore, csar aims to be flexible code-wise. Most of its API will be publicly exposed and documented. Third-party developers will be able to use this to embed csar into complicated build processes and other applications.

\subsection{Pre-requisite Knowledge}
``Code refactoring is the process of restructuring existing computer code—changing the factoring—without changing its external behaviour. Refactoring improves non-functional attributes of the software." \cite{wikipediacoderefactoring}

``Semantics-based search seeks to improve search accuracy by understanding the searcher's intent and the contextual meaning of terms as they appear in the searchable dataspace, whether on the Web or within a closed system, to generate more relevant results." \cite{wikipediacompilercompiler} Henceforth, this is what is meant by `code search' or `search'.

Searching increases developer productivity by enabling reuse, and it is important to address properly because it accounts for a significant portion of a developer's activity. \cite{semanticscodesearch,solvingsearchforsourcecode}

There have been attempts to solve searching which have failed, the reasons for this includes: trying to do too much or too little, requiring too much user input, and yielding irrelevant search results. \cite{semanticscodesearch,solvingsearchforsourcecode}

Refactoring increases developer productivity by attempting to automate common tasks, and it is important to address properly because it accounts for a significant portion of a developer's activity. \cite{surveyofsoftwarerefactoring,howwerefactor}

There have been attempts to solve refactoring which have failed, the reasons for this includes: the degree of automation, reliability, configurability and openness, coverage, scalability, and language independence. \cite{surveyofsoftwarerefactoring}
We can conclude that existing tools have failed because they are underused. \cite{howwerefactor}

They are hard to implement because one of the requirements for both is language-agnosticism\cite{surveyofsoftwarerefactoring,semanticscodesearch} which creates a trade-off scenario, with regards to expressiveness versus how language-agnostic you want the system to be.

``Parsing, syntax analysis or syntactic analysis is the process of analysing a string of symbols, either in natural language or in computer languages, conforming to the rules of a formal grammar." \cite{wikipediaparsing}

``The visitor design pattern is a way of separating an algorithm from an object structure on which it operates." \cite{wikipediavisitorpattern}

ANTLR is a parser-generator. \cite{wikipediaantlr}

```A compiler-compiler (also known as a parser-generator) is a programming tool that creates a parser, interpreter, or compiler from some form of formal description of a language and machine. The input may be a text file containing the grammar written in BNF or EBNF that defines the syntax of a programming language, and whose generated output is some source code of the parser for the programming language, although other definitions exist." \cite{wikipediacompilercompiler}

% Requirements
\section{Requirements}
\subsection{General Requirements}
\begin{itemize}
    \item A user guide detailing how to use the tool and its query language.
    \item A custom query language to describe the operations to carry out.
    \item Parsing of source code.
    \item Language-agnostic searching.
    \item Custom search domains.
    \item Language-agnostic refactoring.
    \item Flexible program output.
    \item High efficiency.
\end{itemize}

\subsection{Selected Requirements (Scope)}
The project has strict deadlines, so not every feature will be fully implemented.
The scope of this project will be detailed in this section.

The query language will have two versions: 1.x.x (implemented) and ≥ 2.x.x (potential improvements).
The implemented version will formally define the scope of the query language in the implementation, and the potential improvements version will define a more exhaustive schema.
My goal is not to develop an exhaustive query language which can express any language element in any language since it would take very long (it would constitute an entire project itself), hence 2.x.x will be more exhaustive than 1.x.x but not the ultimate query language.

Parsing of java source code (Java 8) will be supported.
csar will be designed such that other programming languages can easily be integrated into it in the future.
They will just need to write a parser written for them, analogously to how the java parser will be written.

Searching will be implemented to only work on methods (finding their definitions and usages) for now.
To implement it for the other language elements described in the query language would be as simple as copy-pasting the code for method searching and changing the types and getters involved.
However, this would be a greatly time consuming and tedious task.
It is also possible that further complications may arise which may need to be addressed in the form of post-processors for the programming languages, this is especially true for dynamic programming languages.

It will also support narrowing the search domain by a `.gitignore' file for directories which are git repositories, and by custom `.csarignore' file. Support for other version control systems are a backlog task and may not be fulfilled, but will follow trivially from the git implementation.
The git implementation will require calling the git binary with a specific argument and reading the output, which will reveal which files it is currently tracking.

Refactoring is very complicated and time consuming, so we will only consider two operations.
The first is changing method parameters, this involves resolving all usages of the method in question (in various contexts), modifying the method calls and its definition and ensuring no naming collisions occur.
The second is renaming methods, this should follow from changing method parameters, since if we resolve all method usages we should be able to simply rename them all and ensure no naming collisions occur.

The program output could technically support thousands of formats, but for simplicity it will only support two: plain text and JSON.
If alternatives are required, a third-party developer will be able to easily add their own result formatter.

Efficiency will mainly be addressed by introducing multi-threading and caching where possible.
Specific algorithms to be used are currently unknown, but may become available as the details of the implementation are gradually addressed.

\subsection{Back-logged Requirements}
These requirements are non-essential, but may be addressed if there is sufficient time, or if priorities shift.
The implementation details of each will be outlined.

\subsubsection{Indexing parsed project source code}
We want to index previously parsed project code and use this to speed up further interactions with the same project code.
We also want to maintain an updated index of the code.

We have two storage approaches we can take:
\begin{enumerate}
    \item Storage Approach: Flat Files\newline
    Either map the files to a parallel hierarchy in `.csar` which contains their parsed outputs, or, store them all in the same folder where their file names are the hashes of the input files.
    The second approach may cause problems if hash collisions occur, so care must be taken when choosing the hashing algorithm to be used.
    The last modified dates of the source code and their parsed code can be used to determine which files require updating.
    \item Storage Approach: Database (i.e. SQLite)\newline
    Store a `(Path, LastModified, ParsedCode)` relation in the database, preferably in a `.csar` directory.
    Note: `LastModified` is a date, which is the last time that file was modified, as of when it was parsed.
    We can use this to determine which files need updating.
\end{itemize}

It is important to note that using the last modified dates of files can be error-prone, since they can be spoofed, but it would offer no advantage to an attacker.

\subsubsection{Supporting Mercurial (hg)/Subversion (svn) repositories}
This would be done analogously to the git implementation, but the program arguments we use when invoking their binaries will be different.
Some possibilities are listed below:
\begin{itemize}
    \item Hg: 'hg status --all`
    \item Svn: `svn list -R' or `svn status'
\end{itemize}

\subsubsection{Support for further searching}
The process for this is described earlier, I would simply have to repeat the process for each additional element I want to support searching for.

\subsubsection{IntelliJ IDEA Integration}
csar can be integrated into this IDE in one of two ways:
\begin{itemize}
    \item Internally - csar can be implemented as an alternative to IDEA's structural search,
    this would enable it to carry out the following tasks:
    identifier usage finding, overridden method finding, type hierarchy resolving, refactoring, and semantics-based searching.
    This requires placing our code in \href{https://github.com/JetBrains/intellij-community/tree/master/platform/structuralsearch/source/com/intellij/structuralsearch}{platform/structuralsearch/...} and creating adapters to enable our code to provide the same interface as the current IDEA ones, to ensure maximum compatibility.
    \item As a Plugin - csar can be implemented as a third-party plugin which introduces a new query field.
    This field would allow users to type csar queries and then execute them, displaying the results in a standard IDEA result window.
\end{itemize}

% Design
\section{Design}
\subsection{Component Overview}
Overview:\newline
CLI $\rightarrow$ Csar Query Parser $\rightarrow$ Project Code Parser $\rightarrow$ Code Post-processors $\rightarrow$ Search $\rightarrow$ Refactor $\rightarrow$ Results.

CLI:\newline
csar receives some command-line arguments including a non-optional search query.
These determine what tasks csar will execute.

Its usage format is shown below:
\begin{lstlisting}
Usage: java -jar csar.jar [options] Search query
  Options:
    --threads, -t
      Thread count (default: 1)
    --log-level
      Log level (default: INFO)
      Possible Values (most restrictive to least): ERROR, WARN, INFO, DEBUG, TRACE
    --format, -f
      Output format (default: PlainText)
      Possible Values: PlainText, JSON
    --output, -o
      Output file name
    --narrow-search
      Narrow search domain (default: true)
    --ignore-file
      Ignore file (default: .csarignore)
    --benchmark
      Print benchmarking values (default: false)
    --project-url, --url
      Print project URL
    --help, -h
      Print help information
\end{lstlisting}

These values are stored in an instance of `CsarContext' using JCommander.
JCommander will try to match the command-line arguments with fields in said object using the values in their `@Parameter' annotations.

Then, `CsarFactory' will use this instance of `CsarContext' to create a corresponding instance of `Csar'.
At this stage, a project iterator which determines files to parse is also created.

Csar Query Parser:\newline
The csar query in `CsarContext' will be parsed using the corresponding ANTLR4 grammar. Each csar query is comprised of four parts, but only the first is required:
\begin{itemize}
    \item `searchTarget' - The element to select.
    \item `containsQuery' - What `searchTarget' should contain within it.
    \item `fromTarget' - Where `searchTarget' should be looked for in.
    \item `refactorDescriptor' - The transformation to apply to `searchTarget'.
\end{itemize}

Project Code Parser:\newline
The project code will be parsed (currently only Java 8 is supported).
This is after csar query is parsed because typically it takes longer, and an invalid csar query causes early.
It will also perform some code validation because the Java 8 ANTLR4 grammar relies on post-processing for correctness.

Code Post-processors:\newline
The parsed project code is post-processed for extra information which may be needed for searching.
This includes type hierarchy resolving, overridden methods resolving, and mapping method usages to method definitions (unimplemented).

Search:\newline
The parsed project code is searched using the visitor design pattern.
Each language element in each code file is visited, and if a match to the language descriptor we are looking for is found, then that element is added to the list of search results.
This will soon also handle the `FROM` and `CONTAINS` clauses from csar query (unimplemented).

Refactor:\newline
The parsed project code will be refactored, and changes will be written to source code files (unimplemented).

Results:\newline
The search and refactor results are printed.

Note: If an unrecoverable error occurs at any of the aforementioned stages, the error will be displayed in a user-friendly format and csar will terminate.
The user may be able to override this behaviour through sub-classing.

\subsection{Running Example}
Suppose we invoke csar from the command-line with the following command: `java -jar csar.jar SELECT method:def:parse REFACTOR RENAME:parse2 -t 1'.
Furthermore, suppose our project has the following code files in the directory `/project/':

`Main.java':
\begin{lstlisting}[language=Java]
public class Main extends Parser {

  public static void main(String[] args) {
    new Main().run();
  }

  public void run() {
    parse();
  }
}
\end{lstlisting}

`Parser.java':
\begin{lstlisting}[language=Java]
public class Parser {

  public void parse() {
    // ...
  }
}
\end{lstlisting}

Firstly, these command-line arguments will be parsed and be used to instantiate a corresponding instance of `Csar'. The directory is not home to a supported version control and does not have a `.csarignore' file so no filtering of its contents will be applied.

Secondly, the project code will be parsed (on a single thread) and then post-processed.

Thirdly, the search will be performed. In this case method definitions which have the name `parse' will be stored in a search results list.

We will have the following search results:
\begin{lstlisting}
(path='/project/Parser.java', lineNumber=3, codeFragment='  public void parse() {')
\end{lstlisting}

These results will be formatted and then printed as follows:
\begin{lstlisting}
Search Results:
/project/Parser.java:3 - '  public void parse() {'
\end{lstlisting}

Fourthly, the refactor will be performed. In this case all definitions and corresponding usages (these are graphed in the code post-processing) in the search results list will have their identifier names changed to `parse2'.
These changes will then be written to the relevant source code files.

We will end up with the following code files:

`Main.java':
\begin{lstlisting}[language=Java]
public class Main extends Parser {

  public static void main(String[] args) {
    new Main().run();
  }

  public void run() {
    parse2();
  }
}
\end{lstlisting}

`Parser.java':
\begin{lstlisting}[language=Java]
public class Parser {

  public void parse2() {
    // ...
  }
}
\end{lstlisting}

Furthermore, we will have the following refactor results:
\begin{lstlisting}
(path='/project/Main.java', lineNumber=8, codeFragment='    parse2();')
(path='/project/Parser.java', lineNumber=3, codeFragment='  public void parse2() {')
\end{lstlisting}

These results will be formatted and then printed as follows:
\begin{lstlisting}
Refactor Results:
/project/Main.java:8 - '    parse2();'
/project/Parser.java:3 - '  public void parse2() {'
\end{lstlisting}

Finally, csar will terminate.

% Background Material
\section{Background Material}
\subsection{Related Academic Works}
\begin{itemize}
    \item \href{http://www.sciencedirect.com.ezproxy.library.qmul.ac.uk/science/article/pii/S1045926X16300970?_rdoc=1&_fmt=high&_origin=gateway&_docanchor=&md5=b8429449ccfc9c30159a5f9aeaa92ffb&ccp=y}{Ge X, Shepherd D, Damevski K, Murphy-Hill E. ``Design and evaluation of a multi-recommendation system for local code search." International Journal of Computer Applications 138.6 (2016): 9-13.}\newline
    This work is regarding plain-text code search in local projects and includes various ideas for optimisations.
    \item \href{https://link-springer-com.ezproxy.library.qmul.ac.uk/article/10.1007%2Fs10515-014-0170-2}{Wang S, Lo D, Jiang L. ``AutoQuery: Automatic Construction of Dependency Queries for Code Search." Automated Software Engineering 23.3 (2016): 393-425.}\newline
    This work is regarding dependence-based code searching. They have also devised a query language to make producing Program Dependency Graphs easier.  
    \item \href{http://dl.acm.org.ezproxy.library.qmul.ac.uk/citation.cfm?id=2393612}{Shepherd D, Damevski K, Ropski B, Fritz T. ``Sando: an extensible local code search framework." Proceedings of the ACM SIGSOFT 20th International Symposium on the foundations of software engineering (2012).}\newline
    This work is regarding an extensible plain-text code search in local projects.
\end{itemize}

There are also a lot of material on code search engines, ranking code samples and text matching, but these are largely unrelated to the task at hand.

\subsection{Related Programs}
\begin{itemize}
    \item \href{https://en.wikipedia.org/wiki/Grep}{grep}\newline
    A command-line utility for searching plain-text data against a regular expression.
    \item \href{https://beyondgrep.com/}{ack}\newline
    A command-line utility for searching plain-text data against a regular expression - essentially a better grep.
    \item \href{https://github.com/ggreer/the_silver_searcher}{ag (aka the silver searcher)}\newline
    A command-line utility for searching plain-text data against a regular expression - essentially a better ack.
\end{itemize}

\subsection{Query Language Analysis}
The following languages do not necessarily address my problem but they may influence the development of my own query language.

\subsubsection{AutoQuery}
Its queries are broken up into the following groups: program element types (variable, function, etc.) and identifier (if applicable), program element descriptions (contains, ofType, atLine, etc.), relation descriptions (depends on, etc.) and finally targets.
Each group can have 0 or more pieces of information within it, so it is descriptive.

Its language is unnatural (with respect to English) and is very rigid.
You can specify file, line number, types, and various elementary language elements (classes, methods, control flow).
It is not very expressive: it cannot represent try-catch blocks, anonymous methods/classes, and a long list of such constructs.

\subsubsection{AspectJ}
\href{https://eclipse.org/aspectj/doc/next/progguide/starting-aspectj.html}{AspectJ} has developed a language which it uses to address the problems presented by aspect-oriented programming.  

Their queries have a syntax that closely resembles that of Java. Examples below:
\begin{itemize}
    \item `call(void Point.setX(int)) || call(void Point.setY(int))'`'
    \item `call(void Figure.make*(..))'
    \item `call(public * Figure.* (..))
\end{itemize}

You can restrict the domain of queries with logical operators (and, or and not).
It has limited wildcards (`*', `..' which serves as `*' specially for method parameters, but it lacks `?').

You can define a query with an alias, which helps address the Don't Repeat Yourself principle, and thus verbosity.
I can also use this to provide coding standards verification (i.e. define queries and run them against the project, with matches corresponding errors in standards).
You can define method parameters as a type list or a named-type list which is flexible and expressive.

One issue is csar aims to be language-agnostic, so adopting a Java-like syntax will be unintuitive for non-Java programmers.

The syntax fails for dynamically-typed languages where types are not explicitly defined, so a method with signature: `my\_method(int)' would be invalid (or require additional processing to make work).
A solution to this is accepting variable name lists.

\subsubsection{Infer}
\href{https://github.com/facebook/infer}{Infer} has developed a language called \href{https://code.facebook.com/posts/277643589367408/}{AL} which it uses to define code templates corresponding to code stink. Example below:  

\begin{lstlisting}
DEFINE-CHECKER STRONG_DELEGATE_WARNING = {
    LET name_contains_delegate = declaration_has_name(REGEXP("[dD]elegate"));
    LET name_does_not_contain_queue = NOT declaration_has_name(REGEXP("[qQ]ueue"));

    SET report_when =
        WHEN
            name_contains_delegate
            AND name_does_not_contain_queue
            AND is_strong_property()
        HOLDS-IN-NODE ObjCPropertyDecl;

    SET message = "Property or ivar %decl_name% declared strong";
    SET suggestion = "In general delegates should be declared weak or assign";
};
\end{lstlisting}

It is very descriptive (allows compositions with `AND', `NOT', `WHEN' etc.) and intuitive (similar to SQL). You can define strings as regex patterns, this is a powerful feature.
The language is verbose and thus does not resonate with csar's competitors, which use single line queries.
However, declarations and response messages can be useful for creating complex tools with csar (i.e. code convention checks).

\subsection{Code References}
\begin{itemize}
    \item Ignore files syntax - \url{https://git-scm.com/docs/gitignore} and \url{https://github.com/EE/gitignore-to-glob/blob/master/lib/gitignore-to-glob.js}
    \item Test cases for ignore files - \url{https://www.atlassian.com/git/tutorials/gitignore}
    \item Git repository integration - \url{https://git-scm.com/docs/git-ls-files}
    \item Java 8 ANTLR Grammar - \href{https://github.com/antlr/grammars-v4/blob/02711067f82bed8e0c8dfd25e80f4f8ae2472abd/java8-pt/JavaLexer.g4}{Java 8 Lexer}, \href{https://github.com/antlr/grammars-v4/blob/02711067f82bed8e0c8dfd25e80f4f8ae2472abd/java8-pt/JavaParser.g4}{Java 8 Parser}, \href{https://github.com/antlr/grammars-v4/blob/02711067f82bed8e0c8dfd25e80f4f8ae2472abd/_grammar-test/src/test/java/TestJava8pt.java}{Java 8 Test} and \href{https://github.com/antlr/grammars-v4/blob/02711067f82bed8e0c8dfd25e80f4f8ae2472abd/java8-pt/examples/AllInOne8.java}{Java 8 Test Input}
    \item `JAVA\_LETTER' rule in `CsarLexer' - \url{https://github.com/antlr/grammars-v4/blob/master/java8/Java8.g4}
    \item Using JCommander parameters in `CsarContext' - \url{http://jcommander.org/}
    \item ANTLR settings in `build.gradle' - \url{https://docs.gradle.org/4.0.1/userguide/antlr\_plugin.html\#sec:controlling\_the\_antlr\_generator\_process}
    \item JaCoCo in `build.gradle' - \url{http://www.jworks.nl/2013/06/03/jacoco-code-coverage-with-gradle/}
\end{itemize}

% Time Plan
\section{Time Plan}
The work completed so far can be seen in full on the Github repository's \href{https://github.research.its.qmul.ac.uk/ec15116/csar/commits/master}{commits}.
A concise description is that: the command-line interface, csar query language parsing, Java code parsing, and search (partially) are completed.

\begin{itemize}
    \item 08/12/2017 - Interim report and risk assessment.
    \item 18/12/2017 - Mapping method usages to method definitions.
    \item 08/01/2018 - Implement searching method usages.
    \item 11/01/2018 - Finish searching (supporting from and contains query clauses).
    \item 12/02/2018 - Implement refactoring.
    \item 01/03/2018 - Implement full language-agnosticism.
    \item 19/03/2018 - Draft final report (begin after Implement refactoring).
    \item 23/04/2018 - Final report.
    \item 25/04/2018 - Presentation slides.
\end{itemize}

% Risk Assessment
\section{Risk Assessment}
\begin{tabulary}{1.3\textwidth}{LLLLL}
Description of risk & Description of impact & Likelihood rating & Impact rating & Preventative actions \\
Low motivation/Burn out & Overdue/incomplete work & Medium & High & Schedule project work carefully, leave time for entertainment. \\
Busy schedule/Poor time management & Overdue/incomplete work & Medium & High & Schedule carefully, try to get work done on time as necessary. \\
Advisor has busy schedule & Inadequate work quality. & Medium & Low & Take initiative as necessary, use library resources to fill in gaps in knowledge. \\
Code defects & Inadequate program functionality. & Medium & Medium & Try to fix them, if not possible then write about them in the report and leave them. \\
Code bugs & Inadequate program quality. & Medium & Low & Try to fix them, if not possible then write about them in the report and leave them. Do not pretend they do not exist. \\
Code quality & More difficult development. & Low & Low & Incremental development should help prevent this. \\
Incomplete design & Pre-requisite to implementation. & Medium & High & Schedule work on the design to keep up with the pace of the programming. \\
IDE crash & Lost work & Low & High & Save often, use version control. \\
\end{tabulary}

% Bibliography
\begin{thebibliography}{9}

\bibitem{wikipediacoderefactoring} Wikipedia. (2017) \textit{Code refactoring - Wikipedia}. Available at: https://en.wikipedia.org/wiki/Code\_refactoring [Accessed 18th November 2017].

\bibitem{wikipediaparsing} Wikipedia. (2017) \textit{Parsing - Wikipedia}. Available at: https://en.wikipedia.org/wiki/Parsing [Accessed 18th November 2017].

\bibitem{wikipediavisitorpattern} Wikipedia. (2017) \textit{Visitor pattern - Wikipedia}. Available at https://en.wikipedia.org/wiki/Visitor\_pattern [Accessed 18th November 2017].

\bibitem{wikipediaantlr} Wikipedia. (2017) \textit{ANTLR - Wikipedia}. Available at https://en.wikipedia.org/wiki/ANTLR [Accessed 18th November 2017].

\bibitem{wikipediacompilercompiler} Wikipedia. (2017) \textit{Compiler-compiler - Wikipedia}. Available at https://en.wikipedia.org/wiki/Compiler-compiler [Accessed 18th November 2017]

\bibitem{wikipediasemanticsearch} Wikipedia. (2017) \textit{Semantic search - Wikipedia}. Available at https://en.wikipedia.org/wiki/Semantic\_search [Accessed 27th November 2017].

\bibitem{surveyofsoftwarerefactoring} Mens, Tom \& Tourwe, Tom. (2004). A survey of software refactoring. \textit{IEEE Transactions on Software Engineering; New York}. 30 (2). 126-139. Available from: http://ieeexplore.ieee.org/document/1265817/ [Accessed 4th December 2017].

\bibitem{semanticscodesearch} Reiss, Steven P. (2009). Semantics-based code search. \textit{Proceedings of the 31st International Conference on software engineering}. 30 (2). 243-253. Available from: https://dl.acm.org/citation.cfm?id=1555040 [Accessed 4th December 2017].

\bibitem{solvingsearchforsourcecode} Dobos, Daniel \& Elbaum, Sebastian \& Stolee, Kathryn T. (2014). Solving the Search for Source Code. \textit{ACM Transactions on Software Engineering and Methodology}. 23 (3). 1-45. Available from: https://dl.acm.org/citation.cfm?id=2581377 [Accessed 4th December 2017].

\bibitem{howwerefactor} Murphy-Hill, Emerson \& Parnin, Chris \& Black, Andrew P. (2012). How We Refactor, and How We Know It. \textit{IEEE Transactions on Software Engineering}. 38 (1). 5-18. Available from: http://ieeexplore.ieee.org/document/6112738/ [Accessed 4th December 2017].

\end{thebibliography}

\end{document}